#include "stdio.h"
#include "conio.h"
#include "math.h"
#include "stdlib.h"
#include "windows.h"

#define N 10000

					//ЛАБАРТОРНАЯ РАБОТА №5		ВАРИАНТ 2
		//ЗАДАНИЕ: СОРТИРОВКА ШЕЛЛА. ЧАСТИЧНУЮ СОРТИРОВКУ С ЗАДАННЫМ ШАГОМ,  
		//		   НАЧИНАЯ С ЗАДАННОГО ЭЛЕМЕНТА ОФОРМИТЬ В ВИДЕ ФУНКЦИИ. 
		//		   АЛГОРИТМ ЧАСТИЧНОЙ СОРТИРОВКИ - ВСТАВКА ПОГРУЖЕНИЕМ.
		//		   Если имеется базовый алгоритм сортировки , то аналогично 
		//		   оформить базовый алгоритм и произвести сравнение эффективности.
		
void gotoxy(int x, int y){							//перемещение курсора в координаты 'x' и 'y'
  COORD scrn;    
  HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE);
  scrn.X = x; scrn.Y = y;
  SetConsoleCursorPosition(hOuput,scrn);
}
		
		
int main(){
	int ShellSort(int A[]), PogrujSort(int B[]);	//объявление функций
	int A[N], B[N], i;
	for(i=0;i<N;i++){								//формирует элементы массива случайным образом
		A[i]=rand()%43;
		B[i]=A[i];
	}
	ShellSort(A);									//запуск сортировки Шелла(погружение вставками)
	PogrujSort(B);									//запуск сортировки погружение вставками
	getch();						
}

int ShellSort(int A[]){
	int i, d, k, j, t, z=0, zs=0, H=10, v;
	gotoxy(1,1);
	printf("Massiv          100          1000          10000\n\n");
	for(v=0;v<3;v++){								//цикл для 100, 1000, 10000 повторений
		H*=10;
		for(d=H/2;d>=1;d/=2){												//вычисляет d (интервалл сортировки массива в методе Шелла) при каждой итерации
			for(i=0;i<H;i++){												//сортирует весь массив с вычесленным d
				for(t=H/d,j=t;j>0;j--){										//вычисляет количество интервалов для i-го элемента	
					if (((i+j*d)<=(H-1)) && (A[i+(j-1)*d]<A[i+j*d])){		//проверка на выход за пределы массива и на меньшее значение
						k=A[i+(j-1)*d];										//A[i+(j-1)*d] - элемент с меньшим индексом
						A[i+(j-1)*d]=A[i+j*d];								//j*d - задает интервал и его количество
						A[i+j*d]=k;											//A[i+j*d] - элемент с большим индексом
						z++;												//счетчик перестановок
					}	
				}
			}
		zs+=z;										//суммируем количество перестановок (для статистики)
		z=0;										//обнуляем счетчик
		}
		switch (v){
			case 0: gotoxy(1,4); printf("ShellSort       %d", zs); break;
			case 1: gotoxy(30,4); printf("%d", zs); break;
			case 2: gotoxy(44,4); printf("%d\n", zs); break;
		}
	}
}

int PogrujSort(int B[]){
	int i, d, k, j, t, z=0, zs=0, H=10, v;
	for(v=0;v<3;v++){								//цикл для 100, 1000, 10000 повторений
		H*=10;
		for(i=1;i<=H-1;i++){						//проход по всем элементам массива
			for(j=i;j>0;j--){						//сортирует часть массива до i-го элемента
				if (B[j]>B[j-1]){					//меняет местами в случае большего значения
					k=B[j-1];										
					B[j-1]=B[j];							
					B[j]=k;							
					z++;							//счетчик перестановок
				}	
			}
		zs+=z;										//суммируем количество перестановок (для статистики)
		z=0;										//обнуляем счетчик
		}
		switch (v){
			case 0: gotoxy(1,6); printf("Pogrujenie      %d", zs); break;
			case 1: gotoxy(30,6); printf("%d", zs); break;
			case 2: gotoxy(44,6); printf("%d", zs); break;
		}
	}
}
